"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_turnkey_viem_node_modules_turnkey_api-key-stamper_dist_webcry-35f353"],{

/***/ "(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   toByteString: () => (/* binding */ toByteString),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Converts the hex string to a byte array.\n *\n * @param hex the input\n * @return the byte array output\n * @throws {!Error}\n * @static\n */\nfunction fromHex(hex) {\n    if (hex.length % 2 != 0) {\n        throw new Error(\"Hex string length must be multiple of 2\");\n    }\n    const arr = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < hex.length; i += 2) {\n        arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n    }\n    return arr;\n}\n/**\n * Converts a byte array to hex.\n *\n * @param bytes the byte array input\n * @return hex the output\n * @static\n */\nfunction toHex(bytes) {\n    let result = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        const hexByte = bytes[i].toString(16);\n        result += hexByte.length > 1 ? hexByte : \"0\" + hexByte;\n    }\n    return result;\n}\n/**\n * Base64 encode a byte array.\n *\n * @param bytes the byte array input\n * @param opt_webSafe True indicates we should use the alternative\n *     alphabet, which does not require escaping for use in URLs.\n * @return base64 output\n * @static\n */\nfunction toBase64(bytes, opt_webSafe) {\n    const encoded = btoa(\n    /* padding */\n    toByteString(bytes)).replace(/=/g, \"\");\n    if (opt_webSafe) {\n        return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    }\n    return encoded;\n}\n/**\n * Turns a byte array into the string given by the concatenation of the\n * characters to which the numbers correspond. Each byte is corresponding to a\n * character. Does not support multi-byte characters.\n *\n * @param bytes Array of numbers representing\n *     characters.\n * @return Stringification of the array.\n */\nfunction toByteString(bytes) {\n    let str = \"\";\n    for (let i = 0; i < bytes.length; i += 1) {\n        str += String.fromCharCode(bytes[i]);\n    }\n    return str;\n}\n\n\n//# sourceMappingURL=bytes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvdmllbS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9ieXRlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7QUFDbEQiLCJzb3VyY2VzIjpbIi9ob21lL2phc3Blci9wcm9qZWN0cy9lbGl6YS1tb2RlLWV4YW1wbGUvbm9kZV9tb2R1bGVzL0B0dXJua2V5L3ZpZW0vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9kaXN0L3RpbmsvYnl0ZXMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvdGluay9ibG9iLzZmNzRiOTlhMmJmZTY2NzdlMzY3MDc5OTExNmE1NzI2OGZkMDY3ZmEvamF2YXNjcmlwdC9zdWJ0bGUvYnl0ZXMudHNcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaW5wdXRcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYXJyYXkgb3V0cHV0XG4gKiBAdGhyb3dzIHshRXJyb3J9XG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgaWYgKGhleC5sZW5ndGggJSAyICE9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGV4IHN0cmluZyBsZW5ndGggbXVzdCBiZSBtdWx0aXBsZSBvZiAyXCIpO1xuICAgIH1cbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgYXJyW2kgLyAyXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgYnl0ZSBhcnJheSB0byBoZXguXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGFycmF5IGlucHV0XG4gKiBAcmV0dXJuIGhleCB0aGUgb3V0cHV0XG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIHRvSGV4KGJ5dGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICByZXN1bHQgKz0gaGV4Qnl0ZS5sZW5ndGggPiAxID8gaGV4Qnl0ZSA6IFwiMFwiICsgaGV4Qnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQmFzZTY0IGVuY29kZSBhIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGFycmF5IGlucHV0XG4gKiBAcGFyYW0gb3B0X3dlYlNhZmUgVHJ1ZSBpbmRpY2F0ZXMgd2Ugc2hvdWxkIHVzZSB0aGUgYWx0ZXJuYXRpdmVcbiAqICAgICBhbHBoYWJldCwgd2hpY2ggZG9lcyBub3QgcmVxdWlyZSBlc2NhcGluZyBmb3IgdXNlIGluIFVSTHMuXG4gKiBAcmV0dXJuIGJhc2U2NCBvdXRwdXRcbiAqIEBzdGF0aWNcbiAqL1xuZnVuY3Rpb24gdG9CYXNlNjQoYnl0ZXMsIG9wdF93ZWJTYWZlKSB7XG4gICAgY29uc3QgZW5jb2RlZCA9IGJ0b2EoXG4gICAgLyogcGFkZGluZyAqL1xuICAgIHRvQnl0ZVN0cmluZyhieXRlcykpLnJlcGxhY2UoLz0vZywgXCJcIik7XG4gICAgaWYgKG9wdF93ZWJTYWZlKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVkLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG4vKipcbiAqIFR1cm5zIGEgYnl0ZSBhcnJheSBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuIEVhY2ggYnl0ZSBpcyBjb3JyZXNwb25kaW5nIHRvIGFcbiAqIGNoYXJhY3Rlci4gRG9lcyBub3Qgc3VwcG9ydCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nXG4gKiAgICAgY2hhcmFjdGVycy5cbiAqIEByZXR1cm4gU3RyaW5naWZpY2F0aW9uIG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlU3RyaW5nKGJ5dGVzKSB7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IGZyb21IZXgsIHRvQmFzZTY0LCB0b0J5dGVTdHJpbmcsIHRvSGV4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointDecode: () => (/* binding */ pointDecode)\n/* harmony export */ });\n/* harmony import */ var _bytes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes.mjs */ \"(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs\");\n\n\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts\n *\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * P-256 only\n */\nfunction getModulus() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"115792089210356248762697446949407573530086143415290314195533631308\" +\n        \"867097853951\");\n}\n/**\n * P-256 only\n */\nfunction getB() {\n    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).\n    return BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\");\n}\n/** Converts byte array to bigint. */\nfunction byteArrayToInteger(bytes) {\n    return BigInt(\"0x\" + (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toHex)(bytes));\n}\n/** Converts bigint to byte array. */\nfunction integerToByteArray(i) {\n    let input = i.toString(16);\n    // If necessary, prepend leading zero to ensure that input length is even.\n    input = input.length % 2 === 0 ? input : \"0\" + input;\n    return (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.fromHex)(input);\n}\n/** Returns true iff the ith bit (in lsb order) of n is set. */\nfunction testBit(n, i) {\n    const m = BigInt(1) << BigInt(i);\n    return (n & m) !== BigInt(0);\n}\n/**\n * Computes a modular exponent.  Since JavaScript BigInt operations are not\n * constant-time, information about the inputs could leak.  Therefore, THIS\n * METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * @param b base\n * @param exp exponent\n * @param p modulus\n * @return b^exp modulo p\n */\nfunction modPow(b, exp, p) {\n    if (exp === BigInt(0)) {\n        return BigInt(1);\n    }\n    let result = b;\n    const exponentBitString = exp.toString(2);\n    for (let i = 1; i < exponentBitString.length; ++i) {\n        result = (result * result) % p;\n        if (exponentBitString[i] === \"1\") {\n            result = (result * b) % p;\n        }\n    }\n    return result;\n}\n/**\n * Computes a square root modulo an odd prime.  Since timing and exceptions can\n * leak information about the inputs, THIS METHOD SHOULD ONLY BE USED FOR\n * POINT DECOMPRESSION.\n *\n * @param x square\n * @param p prime modulus\n * @return square root of x modulo p\n */\nfunction modSqrt(x, p) {\n    if (p <= BigInt(0)) {\n        throw new Error(\"p must be positive\");\n    }\n    const base = x % p;\n    // The currently supported NIST curves P-256, P-384, and P-521 all satisfy\n    // p % 4 == 3.  However, although currently a no-op, the following check\n    // should be left in place in case other curves are supported in the future.\n    if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {\n        // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)\n        // q = (p + 1) / 4\n        const q = (p + BigInt(1)) >> BigInt(2);\n        const squareRoot = modPow(base, q, p);\n        if ((squareRoot * squareRoot) % p !== base) {\n            throw new Error(\"could not find a modular square root\");\n        }\n        return squareRoot;\n    }\n    // Skipping other elliptic curve types that require Cipolla's algorithm.\n    throw new Error(\"unsupported modulus value\");\n}\n/**\n * Computes the y-coordinate of a point on an elliptic curve given its\n * x-coordinate.  Since timing and exceptions can leak information about the\n * inputs, THIS METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.\n *\n * P-256 only\n *\n * @param x x-coordinate\n * @param lsb least significant bit of the y-coordinate\n * @return y-coordinate\n */\nfunction getY(x, lsb) {\n    const p = getModulus();\n    const a = p - BigInt(3);\n    const b = getB();\n    const rhs = ((x * x + a) * x + b) % p;\n    let y = modSqrt(rhs, p);\n    if (lsb !== testBit(y, 0)) {\n        y = (p - y) % p;\n    }\n    return y;\n}\n/**\n * Decodes a public key in _compressed_ format.\n *\n * P-256 only\n */\nfunction pointDecode(point) {\n    const fieldSize = fieldSizeInBytes();\n    if (point.length !== 1 + fieldSize) {\n        throw new Error(\"compressed point has wrong length\");\n    }\n    if (point[0] !== 2 && point[0] !== 3) {\n        throw new Error(\"invalid format\");\n    }\n    const lsb = point[0] === 3; // point[0] must be 2 (false) or 3 (true).\n    const x = byteArrayToInteger(point.subarray(1, point.length));\n    const p = getModulus();\n    if (x < BigInt(0) || x >= p) {\n        throw new Error(\"x is out of range\");\n    }\n    const y = getY(x, lsb);\n    const result = {\n        kty: \"EC\",\n        crv: \"P-256\",\n        x: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(x), /* websafe */ true),\n        y: (0,_bytes_mjs__WEBPACK_IMPORTED_MODULE_0__.toBase64)(integerToByteArray(y), /* websafe */ true),\n        ext: true,\n    };\n    return result;\n}\n/**\n * P-256 only\n */\nfunction fieldSizeInBytes() {\n    return 32;\n}\n\n\n//# sourceMappingURL=elliptic_curves.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvdmllbS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdGluay9lbGxpcHRpY19jdXJ2ZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0RBQVE7QUFDbkIsV0FBVyxvREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7QUFDdkIiLCJzb3VyY2VzIjpbIi9ob21lL2phc3Blci9wcm9qZWN0cy9lbGl6YS1tb2RlLWV4YW1wbGUvbm9kZV9tb2R1bGVzL0B0dXJua2V5L3ZpZW0vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9kaXN0L3RpbmsvZWxsaXB0aWNfY3VydmVzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0Jhc2U2NCwgdG9IZXgsIGZyb21IZXggfSBmcm9tICcuL2J5dGVzLm1qcyc7XG5cbi8qKlxuICogQ29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvdGluay9ibG9iLzZmNzRiOTlhMmJmZTY2NzdlMzY3MDc5OTExNmE1NzI2OGZkMDY3ZmEvamF2YXNjcmlwdC9zdWJ0bGUvZWxsaXB0aWNfY3VydmVzLnRzXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUC0yNTYgb25seVxuICovXG5mdW5jdGlvbiBnZXRNb2R1bHVzKCkge1xuICAgIC8vIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODYtNC5wZGYgKEFwcGVuZGl4IEQpLlxuICAgIHJldHVybiBCaWdJbnQoXCIxMTU3OTIwODkyMTAzNTYyNDg3NjI2OTc0NDY5NDk0MDc1NzM1MzAwODYxNDM0MTUyOTAzMTQxOTU1MzM2MzEzMDhcIiArXG4gICAgICAgIFwiODY3MDk3ODUzOTUxXCIpO1xufVxuLyoqXG4gKiBQLTI1NiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGdldEIoKSB7XG4gICAgLy8gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4Ni00LnBkZiAoQXBwZW5kaXggRCkuXG4gICAgcmV0dXJuIEJpZ0ludChcIjB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YlwiKTtcbn1cbi8qKiBDb252ZXJ0cyBieXRlIGFycmF5IHRvIGJpZ2ludC4gKi9cbmZ1bmN0aW9uIGJ5dGVBcnJheVRvSW50ZWdlcihieXRlcykge1xuICAgIHJldHVybiBCaWdJbnQoXCIweFwiICsgdG9IZXgoYnl0ZXMpKTtcbn1cbi8qKiBDb252ZXJ0cyBiaWdpbnQgdG8gYnl0ZSBhcnJheS4gKi9cbmZ1bmN0aW9uIGludGVnZXJUb0J5dGVBcnJheShpKSB7XG4gICAgbGV0IGlucHV0ID0gaS50b1N0cmluZygxNik7XG4gICAgLy8gSWYgbmVjZXNzYXJ5LCBwcmVwZW5kIGxlYWRpbmcgemVybyB0byBlbnN1cmUgdGhhdCBpbnB1dCBsZW5ndGggaXMgZXZlbi5cbiAgICBpbnB1dCA9IGlucHV0Lmxlbmd0aCAlIDIgPT09IDAgPyBpbnB1dCA6IFwiMFwiICsgaW5wdXQ7XG4gICAgcmV0dXJuIGZyb21IZXgoaW5wdXQpO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGl0aCBiaXQgKGluIGxzYiBvcmRlcikgb2YgbiBpcyBzZXQuICovXG5mdW5jdGlvbiB0ZXN0Qml0KG4sIGkpIHtcbiAgICBjb25zdCBtID0gQmlnSW50KDEpIDw8IEJpZ0ludChpKTtcbiAgICByZXR1cm4gKG4gJiBtKSAhPT0gQmlnSW50KDApO1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIG1vZHVsYXIgZXhwb25lbnQuICBTaW5jZSBKYXZhU2NyaXB0IEJpZ0ludCBvcGVyYXRpb25zIGFyZSBub3RcbiAqIGNvbnN0YW50LXRpbWUsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnB1dHMgY291bGQgbGVhay4gIFRoZXJlZm9yZSwgVEhJU1xuICogTUVUSE9EIFNIT1VMRCBPTkxZIEJFIFVTRUQgRk9SIFBPSU5UIERFQ09NUFJFU1NJT04uXG4gKlxuICogQHBhcmFtIGIgYmFzZVxuICogQHBhcmFtIGV4cCBleHBvbmVudFxuICogQHBhcmFtIHAgbW9kdWx1c1xuICogQHJldHVybiBiXmV4cCBtb2R1bG8gcFxuICovXG5mdW5jdGlvbiBtb2RQb3coYiwgZXhwLCBwKSB7XG4gICAgaWYgKGV4cCA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBiO1xuICAgIGNvbnN0IGV4cG9uZW50Qml0U3RyaW5nID0gZXhwLnRvU3RyaW5nKDIpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZXhwb25lbnRCaXRTdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIHJlc3VsdCkgJSBwO1xuICAgICAgICBpZiAoZXhwb25lbnRCaXRTdHJpbmdbaV0gPT09IFwiMVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0ICogYikgJSBwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbXB1dGVzIGEgc3F1YXJlIHJvb3QgbW9kdWxvIGFuIG9kZCBwcmltZS4gIFNpbmNlIHRpbWluZyBhbmQgZXhjZXB0aW9ucyBjYW5cbiAqIGxlYWsgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGlucHV0cywgVEhJUyBNRVRIT0QgU0hPVUxEIE9OTFkgQkUgVVNFRCBGT1JcbiAqIFBPSU5UIERFQ09NUFJFU1NJT04uXG4gKlxuICogQHBhcmFtIHggc3F1YXJlXG4gKiBAcGFyYW0gcCBwcmltZSBtb2R1bHVzXG4gKiBAcmV0dXJuIHNxdWFyZSByb290IG9mIHggbW9kdWxvIHBcbiAqL1xuZnVuY3Rpb24gbW9kU3FydCh4LCBwKSB7XG4gICAgaWYgKHAgPD0gQmlnSW50KDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInAgbXVzdCBiZSBwb3NpdGl2ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IHggJSBwO1xuICAgIC8vIFRoZSBjdXJyZW50bHkgc3VwcG9ydGVkIE5JU1QgY3VydmVzIFAtMjU2LCBQLTM4NCwgYW5kIFAtNTIxIGFsbCBzYXRpc2Z5XG4gICAgLy8gcCAlIDQgPT0gMy4gIEhvd2V2ZXIsIGFsdGhvdWdoIGN1cnJlbnRseSBhIG5vLW9wLCB0aGUgZm9sbG93aW5nIGNoZWNrXG4gICAgLy8gc2hvdWxkIGJlIGxlZnQgaW4gcGxhY2UgaW4gY2FzZSBvdGhlciBjdXJ2ZXMgYXJlIHN1cHBvcnRlZCBpbiB0aGUgZnV0dXJlLlxuICAgIGlmICh0ZXN0Qml0KHAsIDApICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRlc3RCaXQocCwgMSkpIHtcbiAgICAgICAgLy8gQ2FzZSBwICUgNCA9PSAzIChhcHBsaWVzIHRvIE5JU1QgY3VydmVzIFAtMjU2LCBQLTM4NCwgYW5kIFAtNTIxKVxuICAgICAgICAvLyBxID0gKHAgKyAxKSAvIDRcbiAgICAgICAgY29uc3QgcSA9IChwICsgQmlnSW50KDEpKSA+PiBCaWdJbnQoMik7XG4gICAgICAgIGNvbnN0IHNxdWFyZVJvb3QgPSBtb2RQb3coYmFzZSwgcSwgcCk7XG4gICAgICAgIGlmICgoc3F1YXJlUm9vdCAqIHNxdWFyZVJvb3QpICUgcCAhPT0gYmFzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IGZpbmQgYSBtb2R1bGFyIHNxdWFyZSByb290XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcXVhcmVSb290O1xuICAgIH1cbiAgICAvLyBTa2lwcGluZyBvdGhlciBlbGxpcHRpYyBjdXJ2ZSB0eXBlcyB0aGF0IHJlcXVpcmUgQ2lwb2xsYSdzIGFsZ29yaXRobS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBtb2R1bHVzIHZhbHVlXCIpO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgeS1jb29yZGluYXRlIG9mIGEgcG9pbnQgb24gYW4gZWxsaXB0aWMgY3VydmUgZ2l2ZW4gaXRzXG4gKiB4LWNvb3JkaW5hdGUuICBTaW5jZSB0aW1pbmcgYW5kIGV4Y2VwdGlvbnMgY2FuIGxlYWsgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBpbnB1dHMsIFRISVMgTUVUSE9EIFNIT1VMRCBPTkxZIEJFIFVTRUQgRk9SIFBPSU5UIERFQ09NUFJFU1NJT04uXG4gKlxuICogUC0yNTYgb25seVxuICpcbiAqIEBwYXJhbSB4IHgtY29vcmRpbmF0ZVxuICogQHBhcmFtIGxzYiBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHktY29vcmRpbmF0ZVxuICogQHJldHVybiB5LWNvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gZ2V0WSh4LCBsc2IpIHtcbiAgICBjb25zdCBwID0gZ2V0TW9kdWx1cygpO1xuICAgIGNvbnN0IGEgPSBwIC0gQmlnSW50KDMpO1xuICAgIGNvbnN0IGIgPSBnZXRCKCk7XG4gICAgY29uc3QgcmhzID0gKCh4ICogeCArIGEpICogeCArIGIpICUgcDtcbiAgICBsZXQgeSA9IG1vZFNxcnQocmhzLCBwKTtcbiAgICBpZiAobHNiICE9PSB0ZXN0Qml0KHksIDApKSB7XG4gICAgICAgIHkgPSAocCAtIHkpICUgcDtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG59XG4vKipcbiAqIERlY29kZXMgYSBwdWJsaWMga2V5IGluIF9jb21wcmVzc2VkXyBmb3JtYXQuXG4gKlxuICogUC0yNTYgb25seVxuICovXG5mdW5jdGlvbiBwb2ludERlY29kZShwb2ludCkge1xuICAgIGNvbnN0IGZpZWxkU2l6ZSA9IGZpZWxkU2l6ZUluQnl0ZXMoKTtcbiAgICBpZiAocG9pbnQubGVuZ3RoICE9PSAxICsgZmllbGRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXByZXNzZWQgcG9pbnQgaGFzIHdyb25nIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgaWYgKHBvaW50WzBdICE9PSAyICYmIHBvaW50WzBdICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgIH1cbiAgICBjb25zdCBsc2IgPSBwb2ludFswXSA9PT0gMzsgLy8gcG9pbnRbMF0gbXVzdCBiZSAyIChmYWxzZSkgb3IgMyAodHJ1ZSkuXG4gICAgY29uc3QgeCA9IGJ5dGVBcnJheVRvSW50ZWdlcihwb2ludC5zdWJhcnJheSgxLCBwb2ludC5sZW5ndGgpKTtcbiAgICBjb25zdCBwID0gZ2V0TW9kdWx1cygpO1xuICAgIGlmICh4IDwgQmlnSW50KDApIHx8IHggPj0gcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IGlzIG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG4gICAgY29uc3QgeSA9IGdldFkoeCwgbHNiKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGt0eTogXCJFQ1wiLFxuICAgICAgICBjcnY6IFwiUC0yNTZcIixcbiAgICAgICAgeDogdG9CYXNlNjQoaW50ZWdlclRvQnl0ZUFycmF5KHgpLCAvKiB3ZWJzYWZlICovIHRydWUpLFxuICAgICAgICB5OiB0b0Jhc2U2NChpbnRlZ2VyVG9CeXRlQXJyYXkoeSksIC8qIHdlYnNhZmUgKi8gdHJ1ZSksXG4gICAgICAgIGV4dDogdHJ1ZSxcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFAtMjU2IG9ubHlcbiAqL1xuZnVuY3Rpb24gZmllbGRTaXplSW5CeXRlcygpIHtcbiAgICByZXR1cm4gMzI7XG59XG5cbmV4cG9ydCB7IHBvaW50RGVjb2RlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGxpcHRpY19jdXJ2ZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/utils.mjs":
/*!******************************************************************************************!*\
  !*** ../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/utils.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertTurnkeyApiKeyToJwk: () => (/* binding */ convertTurnkeyApiKeyToJwk)\n/* harmony export */ });\n/* harmony import */ var _tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tink/elliptic_curves.mjs */ \"(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\nfunction convertTurnkeyApiKeyToJwk(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_tink_elliptic_curves_mjs__WEBPACK_IMPORTED_MODULE_0__.pointDecode)(hexStringToUint8Array(compressedPublicKeyHex));\n    jwk.d = hexStringToBase64urlString(uncompressedPrivateKeyHex);\n    return jwk;\n}\nfunction hexStringToUint8Array(input) {\n    if (input.length === 0 ||\n        input.length % 2 !== 0 ||\n        /[^a-fA-F0-9]/u.test(input)) {\n        throw new Error(`Invalid hex string: ${JSON.stringify(input)}`);\n    }\n    return Uint8Array.from(input\n        .match(/.{2}/g // Split string by every two characters\n    )\n        .map((byte) => parseInt(byte, 16)));\n}\nfunction hexStringToBase64urlString(input) {\n    const buffer = hexStringToUint8Array(input);\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.stringToBase64urlString)(buffer.reduce((result, x) => result + String.fromCharCode(x), \"\"));\n}\n\n\n//# sourceMappingURL=utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvdmllbS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3QvdXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDtBQUNHOztBQUU1RDtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLGdCQUFnQixzRUFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBFQUF1QjtBQUNsQzs7QUFFcUM7QUFDckMiLCJzb3VyY2VzIjpbIi9ob21lL2phc3Blci9wcm9qZWN0cy9lbGl6YS1tb2RlLWV4YW1wbGUvbm9kZV9tb2R1bGVzL0B0dXJua2V5L3ZpZW0vbm9kZV9tb2R1bGVzL0B0dXJua2V5L2FwaS1rZXktc3RhbXBlci9kaXN0L3V0aWxzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb2ludERlY29kZSB9IGZyb20gJy4vdGluay9lbGxpcHRpY19jdXJ2ZXMubWpzJztcbmltcG9ydCB7IHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nIH0gZnJvbSAnQHR1cm5rZXkvZW5jb2RpbmcnO1xuXG5mdW5jdGlvbiBjb252ZXJ0VHVybmtleUFwaUtleVRvSndrKGlucHV0KSB7XG4gICAgY29uc3QgeyB1bmNvbXByZXNzZWRQcml2YXRlS2V5SGV4LCBjb21wcmVzc2VkUHVibGljS2V5SGV4IH0gPSBpbnB1dDtcbiAgICBjb25zdCBqd2sgPSBwb2ludERlY29kZShoZXhTdHJpbmdUb1VpbnQ4QXJyYXkoY29tcHJlc3NlZFB1YmxpY0tleUhleCkpO1xuICAgIGp3ay5kID0gaGV4U3RyaW5nVG9CYXNlNjR1cmxTdHJpbmcodW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCk7XG4gICAgcmV0dXJuIGp3aztcbn1cbmZ1bmN0aW9uIGhleFN0cmluZ1RvVWludDhBcnJheShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgaW5wdXQubGVuZ3RoICUgMiAhPT0gMCB8fFxuICAgICAgICAvW15hLWZBLUYwLTldL3UudGVzdChpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhleCBzdHJpbmc6ICR7SlNPTi5zdHJpbmdpZnkoaW5wdXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGlucHV0XG4gICAgICAgIC5tYXRjaCgvLnsyfS9nIC8vIFNwbGl0IHN0cmluZyBieSBldmVyeSB0d28gY2hhcmFjdGVyc1xuICAgIClcbiAgICAgICAgLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG59XG5mdW5jdGlvbiBoZXhTdHJpbmdUb0Jhc2U2NHVybFN0cmluZyhpbnB1dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGhleFN0cmluZ1RvVWludDhBcnJheShpbnB1dCk7XG4gICAgcmV0dXJuIHN0cmluZ1RvQmFzZTY0dXJsU3RyaW5nKGJ1ZmZlci5yZWR1Y2UoKHJlc3VsdCwgeCkgPT4gcmVzdWx0ICsgU3RyaW5nLmZyb21DaGFyQ29kZSh4KSwgXCJcIikpO1xufVxuXG5leHBvcnQgeyBjb252ZXJ0VHVybmtleUFwaUtleVRvSndrIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signWithApiKey: () => (/* binding */ signWithApiKey)\n/* harmony export */ });\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.mjs */ \"(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/utils.mjs\");\n/* harmony import */ var _turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turnkey/encoding */ \"(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/encoding/dist/index.mjs\");\n\n\n\n/// <reference lib=\"dom\" />\nconst signWithApiKey = async (input) => {\n    const { content, publicKey, privateKey } = input;\n    const key = await importTurnkeyApiKey({\n        uncompressedPrivateKeyHex: privateKey,\n        compressedPublicKeyHex: publicKey,\n    });\n    return await signMessage({ key, content });\n};\nasync function importTurnkeyApiKey(input) {\n    const { uncompressedPrivateKeyHex, compressedPublicKeyHex } = input;\n    const jwk = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.convertTurnkeyApiKeyToJwk)({\n        uncompressedPrivateKeyHex,\n        compressedPublicKeyHex,\n    });\n    return await crypto.subtle.importKey(\"jwk\", jwk, {\n        name: \"ECDSA\",\n        namedCurve: \"P-256\",\n    }, false, // not extractable\n    [\"sign\"] // allow signing\n    );\n}\nasync function signMessage(input) {\n    const { key, content } = input;\n    const signatureIeee1363 = await crypto.subtle.sign({\n        name: \"ECDSA\",\n        hash: \"SHA-256\",\n    }, key, new TextEncoder().encode(content));\n    const signatureDer = convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));\n    return (0,_turnkey_encoding__WEBPACK_IMPORTED_MODULE_1__.uint8ArrayToHexString)(signatureDer);\n}\n/**\n * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:\n * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa\n *\n * Turnkey expects the signature encoding to be DER-encoded ASN.1:\n * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149\n *\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114\n *\n * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.\n *\n * @param ieee the ECDSA signature in IEEE encoding\n * @return ECDSA signature in DER encoding\n */\nfunction convertEcdsaIeee1363ToDer(ieee) {\n    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {\n        throw new Error(\"Invalid IEEE P1363 signature encoding. Length: \" + ieee.length);\n    }\n    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));\n    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));\n    let offset = 0;\n    const length = 1 + 1 + r.length + 1 + 1 + s.length;\n    let der;\n    if (length >= 128) {\n        der = new Uint8Array(length + 3);\n        der[offset++] = 48;\n        der[offset++] = 128 + 1;\n        der[offset++] = length;\n    }\n    else {\n        der = new Uint8Array(length + 2);\n        der[offset++] = 48;\n        der[offset++] = length;\n    }\n    der[offset++] = 2;\n    der[offset++] = r.length;\n    der.set(r, offset);\n    offset += r.length;\n    der[offset++] = 2;\n    der[offset++] = s.length;\n    der.set(s, offset);\n    return der;\n}\n/**\n * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311\n *\n * Transform a big integer in big endian to minimal unsigned form which has\n * no extra zero at the beginning except when the highest bit is set.\n */\nfunction toUnsignedBigNum(bytes) {\n    // Remove zero prefixes.\n    let start = 0;\n    while (start < bytes.length && bytes[start] == 0) {\n        start++;\n    }\n    if (start == bytes.length) {\n        start = bytes.length - 1;\n    }\n    let extraZero = 0;\n    // If the 1st bit is not zero, add 1 zero byte.\n    if ((bytes[start] & 128) == 128) {\n        // Add extra zero.\n        extraZero = 1;\n    }\n    const res = new Uint8Array(bytes.length - start + extraZero);\n    res.set(bytes.subarray(start), extraZero);\n    return res;\n}\n\n\n//# sourceMappingURL=webcrypto.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHR1cm5rZXkvdmllbS9ub2RlX21vZHVsZXMvQHR1cm5rZXkvYXBpLWtleS1zdGFtcGVyL2Rpc3Qvd2ViY3J5cHRvLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0Q7QUFDRTs7QUFFMUQ7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsWUFBWSxvREFBb0Q7QUFDaEUsZ0JBQWdCLHFFQUF5QjtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLHdFQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBCO0FBQzFCIiwic291cmNlcyI6WyIvaG9tZS9qYXNwZXIvcHJvamVjdHMvZWxpemEtbW9kZS1leGFtcGxlL25vZGVfbW9kdWxlcy9AdHVybmtleS92aWVtL25vZGVfbW9kdWxlcy9AdHVybmtleS9hcGkta2V5LXN0YW1wZXIvZGlzdC93ZWJjcnlwdG8ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbnZlcnRUdXJua2V5QXBpS2V5VG9Kd2sgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyB1aW50OEFycmF5VG9IZXhTdHJpbmcgfSBmcm9tICdAdHVybmtleS9lbmNvZGluZyc7XG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG5jb25zdCBzaWduV2l0aEFwaUtleSA9IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHsgY29udGVudCwgcHVibGljS2V5LCBwcml2YXRlS2V5IH0gPSBpbnB1dDtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBpbXBvcnRUdXJua2V5QXBpS2V5KHtcbiAgICAgICAgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleDogcHJpdmF0ZUtleSxcbiAgICAgICAgY29tcHJlc3NlZFB1YmxpY0tleUhleDogcHVibGljS2V5LFxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBzaWduTWVzc2FnZSh7IGtleSwgY29udGVudCB9KTtcbn07XG5hc3luYyBmdW5jdGlvbiBpbXBvcnRUdXJua2V5QXBpS2V5KGlucHV0KSB7XG4gICAgY29uc3QgeyB1bmNvbXByZXNzZWRQcml2YXRlS2V5SGV4LCBjb21wcmVzc2VkUHVibGljS2V5SGV4IH0gPSBpbnB1dDtcbiAgICBjb25zdCBqd2sgPSBjb252ZXJ0VHVybmtleUFwaUtleVRvSndrKHtcbiAgICAgICAgdW5jb21wcmVzc2VkUHJpdmF0ZUtleUhleCxcbiAgICAgICAgY29tcHJlc3NlZFB1YmxpY0tleUhleCxcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJqd2tcIiwgandrLCB7XG4gICAgICAgIG5hbWU6IFwiRUNEU0FcIixcbiAgICAgICAgbmFtZWRDdXJ2ZTogXCJQLTI1NlwiLFxuICAgIH0sIGZhbHNlLCAvLyBub3QgZXh0cmFjdGFibGVcbiAgICBbXCJzaWduXCJdIC8vIGFsbG93IHNpZ25pbmdcbiAgICApO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbk1lc3NhZ2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGtleSwgY29udGVudCB9ID0gaW5wdXQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlSWVlZTEzNjMgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oe1xuICAgICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgIH0sIGtleSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNvbnRlbnQpKTtcbiAgICBjb25zdCBzaWduYXR1cmVEZXIgPSBjb252ZXJ0RWNkc2FJZWVlMTM2M1RvRGVyKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUllZWUxMzYzKSk7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0hleFN0cmluZyhzaWduYXR1cmVEZXIpO1xufVxuLyoqXG4gKiBgU3VidGxlQ3J5cHRvLnNpZ24oLi4uKWAgb3V0cHV0cyBzaWduYXR1cmUgaW4gSUVFRSBQMTM2MyBmb3JtYXQ6XG4gKiAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vc2lnbiNlY2RzYVxuICpcbiAqIFR1cm5rZXkgZXhwZWN0cyB0aGUgc2lnbmF0dXJlIGVuY29kaW5nIHRvIGJlIERFUi1lbmNvZGVkIEFTTi4xOlxuICogLSBodHRwczovL2dpdGh1Yi5jb20vdGtocS90a2NsaS9ibG9iLzdmMDE1OWFmNWE3MzM4N2ZmMDUwNjQ3MTgwZDFkYjRkM2EzYWEwMzMvc3JjL2ludGVybmFsL2FwaWtleS9hcGlrZXkuZ28jTDE0OVxuICpcbiAqIENvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RpbmsvYmxvYi82Zjc0Yjk5YTJiZmU2Njc3ZTM2NzA3OTkxMTZhNTcyNjhmZDA2N2ZhL2phdmFzY3JpcHQvc3VidGxlL2VsbGlwdGljX2N1cnZlcy50cyNMMTE0XG4gKlxuICogVHJhbnNmb3JtIGFuIEVDRFNBIHNpZ25hdHVyZSBpbiBJRUVFIDEzNjMgZW5jb2RpbmcgdG8gREVSIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSBpZWVlIHRoZSBFQ0RTQSBzaWduYXR1cmUgaW4gSUVFRSBlbmNvZGluZ1xuICogQHJldHVybiBFQ0RTQSBzaWduYXR1cmUgaW4gREVSIGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRFY2RzYUllZWUxMzYzVG9EZXIoaWVlZSkge1xuICAgIGlmIChpZWVlLmxlbmd0aCAlIDIgIT0gMCB8fCBpZWVlLmxlbmd0aCA9PSAwIHx8IGllZWUubGVuZ3RoID4gMTMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSUVFRSBQMTM2MyBzaWduYXR1cmUgZW5jb2RpbmcuIExlbmd0aDogXCIgKyBpZWVlLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0b1Vuc2lnbmVkQmlnTnVtKGllZWUuc3ViYXJyYXkoMCwgaWVlZS5sZW5ndGggLyAyKSk7XG4gICAgY29uc3QgcyA9IHRvVW5zaWduZWRCaWdOdW0oaWVlZS5zdWJhcnJheShpZWVlLmxlbmd0aCAvIDIsIGllZWUubGVuZ3RoKSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gMSArIDEgKyByLmxlbmd0aCArIDEgKyAxICsgcy5sZW5ndGg7XG4gICAgbGV0IGRlcjtcbiAgICBpZiAobGVuZ3RoID49IDEyOCkge1xuICAgICAgICBkZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGggKyAzKTtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IDQ4O1xuICAgICAgICBkZXJbb2Zmc2V0KytdID0gMTI4ICsgMTtcbiAgICAgICAgZGVyW29mZnNldCsrXSA9IGxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCArIDIpO1xuICAgICAgICBkZXJbb2Zmc2V0KytdID0gNDg7XG4gICAgICAgIGRlcltvZmZzZXQrK10gPSBsZW5ndGg7XG4gICAgfVxuICAgIGRlcltvZmZzZXQrK10gPSAyO1xuICAgIGRlcltvZmZzZXQrK10gPSByLmxlbmd0aDtcbiAgICBkZXIuc2V0KHIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHIubGVuZ3RoO1xuICAgIGRlcltvZmZzZXQrK10gPSAyO1xuICAgIGRlcltvZmZzZXQrK10gPSBzLmxlbmd0aDtcbiAgICBkZXIuc2V0KHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGRlcjtcbn1cbi8qKlxuICogQ29kZSBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvdGluay9ibG9iLzZmNzRiOTlhMmJmZTY2NzdlMzY3MDc5OTExNmE1NzI2OGZkMDY3ZmEvamF2YXNjcmlwdC9zdWJ0bGUvZWxsaXB0aWNfY3VydmVzLnRzI0wzMTFcbiAqXG4gKiBUcmFuc2Zvcm0gYSBiaWcgaW50ZWdlciBpbiBiaWcgZW5kaWFuIHRvIG1pbmltYWwgdW5zaWduZWQgZm9ybSB3aGljaCBoYXNcbiAqIG5vIGV4dHJhIHplcm8gYXQgdGhlIGJlZ2lubmluZyBleGNlcHQgd2hlbiB0aGUgaGlnaGVzdCBiaXQgaXMgc2V0LlxuICovXG5mdW5jdGlvbiB0b1Vuc2lnbmVkQmlnTnVtKGJ5dGVzKSB7XG4gICAgLy8gUmVtb3ZlIHplcm8gcHJlZml4ZXMuXG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPCBieXRlcy5sZW5ndGggJiYgYnl0ZXNbc3RhcnRdID09IDApIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKHN0YXJ0ID09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGxldCBleHRyYVplcm8gPSAwO1xuICAgIC8vIElmIHRoZSAxc3QgYml0IGlzIG5vdCB6ZXJvLCBhZGQgMSB6ZXJvIGJ5dGUuXG4gICAgaWYgKChieXRlc1tzdGFydF0gJiAxMjgpID09IDEyOCkge1xuICAgICAgICAvLyBBZGQgZXh0cmEgemVyby5cbiAgICAgICAgZXh0cmFaZXJvID0gMTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoIC0gc3RhcnQgKyBleHRyYVplcm8pO1xuICAgIHJlcy5zZXQoYnl0ZXMuc3ViYXJyYXkoc3RhcnQpLCBleHRyYVplcm8pO1xuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHNpZ25XaXRoQXBpS2V5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJjcnlwdG8ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@turnkey/viem/node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs\n"));

/***/ })

}]);